declare global {
  // Extending the Array constructor
  interface ArrayConstructor {
    /**
     * Creates an array of the specified length filled with values generated by the getValue function.
     * @param count The number of elements to create.
     * @param getValue A function that generates values for the array; it takes the index as an argument.
     * @returns An array of generated values.
     */
    times<T>(count: number, getValue?: (index: number) => T): T[];
  }

  // Extending the Array prototype
  interface Array<T> {
    /**
     * Splits the array into chunks of the specified size.
     * @param chunkSize The size of each chunk.
     * @returns An array of chunks.
     */
    chunk(chunkSize: number): T[][];

    /**
     * Converts the array to a JSON string.
     * @returns A JSON string representation of the array.
     */
    toJson(): string;

    /**
     * Returns the last element of the array.
     * @returns The last element of the array.
     */
    last(): T;

    /**
     * Filters the array to contain only unique elements.
     * @returns An array of unique elements.
     */
    unique(): T[];
  }

  interface Array<T extends number> {
    /**
     * Calculates the minimum value in the number array.
     * @returns The smallest number in the array.
     */
    min(): number;

    /**
     * Calculates the maximum value in the number array.
     * @returns The largest number in the array.
     */
    max(): number;

    /**
     * Calculates the sum of all numbers in the array.
     * @returns The sum of all the numbers.
     */
    sum(): number;

    /**
     * Sort method for arrays of numbers.
     * Sorts the array in ascending order.
     */
    nSort(): number[];
  }

  // Extending the String prototype
  /**
   * Represents the global String object.
   */
  interface String {
    /**
     * Splits the string into chunks of the specified size.
     * @param chunkSize The size of each chunk.
     * @returns An array of string chunks.
     */
    chunk(chunkSize: number): string[];

    /**
     * Converts a string to an array of characters.
     * @returns An array of characters.
     */
    toArray(): string[];

    /**
     * Splits the string into an array of lines.
     * @returns An array of lines.
     */
    lines(): string[];
  }
}

export function polyfill() {
  if (!Array.times) {
    Array.times = function <T>(count: number, getValue?: (index: number) => T): T[] {
      const result = new Array(count);
      for (let i = 0; i < count; i++) result[i] = getValue ? getValue(i) : i;
      return result;
    };
  }

  if (!Array.prototype.chunk) {
    Array.prototype.chunk = function <T>(chunkSize: number): T[][] {
      const result: T[][] = [];
      for (let i = 0; i < this.length; i += chunkSize) {
        const ch = this.slice(i, i + chunkSize);
        result.push(ch);
      }
      return result;
    };
  }

  if (!String.prototype.chunk) {
    String.prototype.chunk = function (chunkSize: number): string[] {
      const result: string[] = [];
      for (let i = 0; i < this.length; i += chunkSize) {
        const ch = this.slice(i, i + chunkSize);
        result.push(ch);
      }
      return result;
    };
  }
  if (!String.prototype.toArray) {
    String.prototype.toArray = function (): string[] {
      return this.split("");
    };
  }
  if (!String.prototype.lines) {
    String.prototype.lines = function (): string[] {
      return this.split("\n");
    };
  }

  if (!Array.prototype.toJson) {
    Array.prototype.toJson = function (): string {
      return JSON.stringify(this);
    };
  }

  if (!Array.prototype.last) {
    Array.prototype.last = function (): string {
      return this.at(-1);
    };
  }

  if (!Array.prototype.unique) {
    Array.prototype.unique = function <T>(): T[] {
      return this.filter((v, i, a) => a.indexOf(v) === i);
    };
  }
  if (!Array.prototype.min) {
    Array.prototype.min = function (): number {
      return Math.min.apply(null, this);
    };
  }
  if (!Array.prototype.max) {
    Array.prototype.max = function (): number {
      return Math.max.apply(null, this);
    };
  }

  if (!Array.prototype.sum) {
    Array.prototype.sum = function (): number {
      return this.reduce((a, b) => a + b, 0);
    };
  }

  if (!Array.prototype.nSort) {
    Array.prototype.nSort = function () {
      return this.sort((a, b) => a - b);
    };
  }
}
